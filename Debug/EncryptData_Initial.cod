; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30723.0 

	TITLE	C:\Users\ivk737\Documents\Visual Studio 2013\Projects\Team6Project\EncryptData_Initial.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?encryptData@@YAHPADH@Z				; encryptData
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	?gptrKey@@3PAEA:DWORD				; gptrKey
EXTRN	?gptrPasswordHash@@3PAEA:DWORD			; gptrPasswordHash
EXTRN	?gdebug1@@3EA:BYTE				; gdebug1
EXTRN	?gdebug2@@3EA:BYTE				; gdebug2
EXTRN	?gEncodeTable@@3PAEA:BYTE			; gEncodeTable
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\ivk737\documents\visual studio 2013\projects\team6project\encryptdata_initial.cpp
;	COMDAT ?encryptData@@YAHPADH@Z
_TEXT	SEGMENT
_resulti$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_data$ = 8						; size = 4
_dataLength$ = 12					; size = 4
?encryptData@@YAHPADH@Z PROC				; encryptData, COMDAT

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 12   : 	int resulti = 0;

  00028	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _resulti$[ebp], 0

; 13   : 
; 14   : 	gdebug1 = 0;					// a couple of global variables that could be used for debugging

  0002f	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gdebug1@@3EA, 0 ; gdebug1

; 15   : 	gdebug2 = 0;					// also can have a breakpoint in C code

  00036	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gdebug2@@3EA, 0 ; gdebug2

; 16   : 
; 17   : 	// You can not declare any local variables in C, but should use resulti to indicate any errors
; 18   : 	// Set up the stack frame and assign variables in assembly if you need to do so
; 19   : 	// access the parameters BEFORE setting up your own stack frame
; 20   : 	// Also, you cannot use a lot of global variables - work with registers
; 21   : 
; 22   : 	__asm {
; 23   : 
; 24   : 		// you will need to reference some of these global variables
; 25   : 		// (gptrPasswordHash or gPasswordHash), (gptrKey or gkey), gNumRounds
; 26   : 
; 27   : 			mov esi, gptrPasswordHash;	put the address of gPasswordHash into esi

  0003d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gptrPasswordHash@@3PAEA ; gptrPasswordHash

; 28   : 			xor eax, eax

  00043	33 c0		 xor	 eax, eax

; 29   : 			mov al, byte ptr[esi];		store gPassword[0] in %al

  00045	8a 06		 mov	 al, BYTE PTR [esi]

; 30   : 			shl ax, 8;					left shift by 8 (multiply by 256)

  00047	66 c1 e0 08	 shl	 ax, 8

; 31   : 			xor ecx, ecx;				set ecx = 0

  0004b	33 c9		 xor	 ecx, ecx

; 32   : 			mov cl, byte ptr[esi + 1];	set cx to gPassword[1]

  0004d	8a 4e 01	 mov	 cl, BYTE PTR [esi+1]

; 33   : 			add ax, cx;					add gPassword[1] to ax, ax is now the starting index for the keyFile

  00050	66 03 c1	 add	 ax, cx

; 34   : 			// ax = starting_index = gPasswordHash[0] * 256 + gPasswordHash[1]
; 35   : 
; 36   : 			xor ebx, ebx;			ebx = control variable(loop)

  00053	33 db		 xor	 ebx, ebx

; 37   : 			xor ecx, ecx

  00055	33 c9		 xor	 ecx, ecx

; 38   : 			mov ecx, dataLength;	ecx = length

  00057	8b 4d 0c	 mov	 ecx, DWORD PTR _dataLength$[ebp]

; 39   : 			cmp ecx, 0;				check that the length is not less than or equal to 0

  0005a	83 f9 00	 cmp	 ecx, 0

; 40   : 			sub ecx, 1;				ecx-- (file length is 1 less than previous)

  0005d	83 e9 01	 sub	 ecx, 1

; 41   : 			jbe lbl_EXIT_ZERO_LENGTH

  00060	76 70		 jbe	 SHORT $lbl_EXIT_ZERO_LENGTH$3

; 42   : 
; 43   : 			mov edi, data;		put the address of first byte of data in %edi

  00062	8b 7d 08	 mov	 edi, DWORD PTR _data$[ebp]

; 44   : 			mov esi, gptrKey;	put the address of gKey into %esi

  00065	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gptrKey@@3PAEA ; gptrKey
$lbl_LOOP$4:

; 45   : 
; 46   : 			//
; 47   : 			// LOOP THROUGH ENTIRE data[] BYTE BY BYTE
; 48   : 			// At each step, data is load from the dl register and that step is performed on the data
; 49   : 			// The modified data is then loaded back into dl
; 50   : 		lbl_LOOP :
; 51   : 				mov dl, byte ptr[edi + ebx];	get the current byte being manipulated

  0006b	8a 14 1f	 mov	 dl, BYTE PTR [edi+ebx]

; 52   : 
; 53   : 				// XOR with the keyFile
; 54   : 				xor dl, byte ptr[esi + eax];	data[ebx] = data[ebx] xor with keyfile[starting_index]

  0006e	32 14 06	 xor	 dl, BYTE PTR [esi+eax]

; 55   : 
; 56   : 				// Free up the registers for use in Steps A - E 
; 57   : 				push eax

  00071	50		 push	 eax

; 58   : 				push ebx

  00072	53		 push	 ebx

; 59   : 				push ecx				

  00073	51		 push	 ecx

; 60   : 				
; 61   : 				// Part D rotate 3 bits right
; 62   : 				ror dl, 3

  00074	c0 ca 03	 ror	 dl, 3

; 63   : 				//*/
; 64   : 
; 65   : 				// Part B invert bits 0, 3, 6
; 66   : 				xor	dl, 0x49; bitMask = 0x49

  00077	80 f2 49	 xor	 dl, 73			; 00000049H

; 67   : 				//*/
; 68   : 
; 69   : 				// Part E, swapping dl with the table value.
; 70   : 				mov dl, gEncodeTable[edx]

  0007a	8a 92 00 00 00
	00		 mov	 dl, BYTE PTR ?gEncodeTable@@3PAEA[edx]

; 71   : 				//*/
; 72   : 
; 73   : 				// Part C swap half nibbles
; 74   : 				mov eax, edx;		load data to be swapped in eax

  00080	8b c2		 mov	 eax, edx

; 75   : 				lea bl, [eax * 4];	shift data to the left 2 and save in bl

  00082	66 8d 1c 85 00
	00 00 00	 lea	 bx, WORD PTR [eax*4]

; 76   : 				and bl, 0xCC;		masking to get indexes we want to swap eg. 1100 1100

  0008a	80 e3 cc	 and	 bl, -52			; ffffffccH

; 77   : 				shr al, 2;			shift original data 2 to the right

  0008d	c0 e8 02	 shr	 al, 2

; 78   : 				and al, 0x33;		mask remaining indexes eg. 0011 0011

  00090	24 33		 and	 al, 51			; 00000033H

; 79   : 				or al, bl;			combine and save in al

  00092	0a c3		 or	 al, bl

; 80   : 				mov dl, al

  00094	8a d0		 mov	 dl, al

; 81   : 				//*/
; 82   : 
; 83   : 				// Part A reverse bit order	- value will be in ch, then saved to dl
; 84   : 				mov al, dl;		load data from previous step into al

  00096	8a c2		 mov	 al, dl

; 85   : 				mov cl, 7;		starting byte position to shift maninpulated data into

  00098	b1 07		 mov	 cl, 7

; 86   : 				mov dh, 1;		dh is a 1 which travels in the byte, moving 1 position from right to left with each iteration

  0009a	b6 01		 mov	 dh, 1

; 87   : 				mov dl, 0;		clear dl for use as loop counter

  0009c	b2 00		 mov	 dl, 0
$LOOP1$5:

; 88   : 
; 89   : 		LOOP1 : push ax

  0009e	66 50		 push	 ax

; 90   : 				AND al, dh;		first time through loop AND with 0000 0000b, second time with 0000 0001b, third time with 0000 0010b...

  000a0	22 c6		 and	 al, dh

; 91   : 				push cx;		save previous value of cx

  000a2	66 51		 push	 cx

; 92   : 				mov cl, dl;		load the value of loop counter into cl

  000a4	8a ca		 mov	 cl, dl

; 93   : 				shr al, cl;		shr by value of loop counter(first time by 0, second time by 1...)

  000a6	d2 e8		 shr	 al, cl

; 94   : 				pop cx;			restore cx

  000a8	66 59		 pop	 cx

; 95   : 				mov bh, al;		load the shifted result into bh

  000aa	8a f8		 mov	 bh, al

; 96   : 				shl bh, cl;		shift into position - '7' for byte 0, '6' for byte 1...

  000ac	d2 e7		 shl	 bh, cl

; 97   : 				OR ch, bh;		OR to the final result

  000ae	0a ef		 or	 ch, bh

; 98   : 				DEC cl;			decrease byte position to shift manipulated data into

  000b0	fe c9		 dec	 cl

; 99   : 				INC dl;			raise the loop counter by 1

  000b2	fe c2		 inc	 dl

; 100  : 				shl dh, 1;		first time through loop dh = 0000 0001b, second time dh = 0000 0010b...

  000b4	d0 e6		 shl	 dh, 1

; 101  : 				pop ax;			

  000b6	66 58		 pop	 ax

; 102  : 				cmp dl, 8;		when loop counter reaches 8, exit to END

  000b8	80 fa 08	 cmp	 dl, 8

; 103  : 				je END

  000bb	74 02		 je	 SHORT $END$6

; 104  : 				jmp LOOP1

  000bd	eb df		 jmp	 SHORT $LOOP1$5
$END$6:

; 105  : 		   END :
; 106  : 				xor dh, dh;		clear dh so that when we loop back to Step E, edx = dl

  000bf	32 f6		 xor	 dh, dh

; 107  : 				mov dl, ch;		save modified data in dl

  000c1	8a d5		 mov	 dl, ch

; 108  : 				//*/
; 109  : 
; 110  : 				// Restore registers back to their previous states and save the modified data
; 111  : 				pop eax

  000c3	58		 pop	 eax

; 112  : 				pop ebx

  000c4	5b		 pop	 ebx

; 113  : 				pop ecx

  000c5	59		 pop	 ecx

; 114  : 				
; 115  : 				// LOOP control
; 116  : 				add eax, 1;			increment keyFile index by 1

  000c6	83 c0 01	 add	 eax, 1

; 117  : 				add ebx, 1;			increment loop counter by 1

  000c9	83 c3 01	 add	 ebx, 1

; 118  : 				cmp ebx, ecx;		if dataLength of the input file > loop counter, exit to lbl_EXIT

  000cc	3b d9		 cmp	 ebx, ecx

; 119  : 				ja lbl_EXIT_END

  000ce	77 07		 ja	 SHORT $lbl_EXIT_END$7

; 120  : 				jmp lbl_LOOP;		if dataLength < loop counter, jump back to lbl_LOOP

  000d0	eb 99		 jmp	 SHORT $lbl_LOOP$4
$lbl_EXIT_ZERO_LENGTH$3:

; 121  : 
; 122  : 		lbl_EXIT_ZERO_LENGTH :
; 123  : 			sub ebx, 1;		decrement ebx to - 1 to return failure

  000d2	83 eb 01	 sub	 ebx, 1

; 124  : 			jmp lbl_EXIT

  000d5	eb 02		 jmp	 SHORT $lbl_EXIT$8
$lbl_EXIT_END$7:

; 125  : 
; 126  : 		lbl_EXIT_END :
; 127  : 			xor ebx, ebx;	ebx = 0, correctly executed

  000d7	33 db		 xor	 ebx, ebx
$lbl_EXIT$8:

; 128  : 
; 129  : 		lbl_EXIT :
; 130  : 			mov resulti, ebx

  000d9	89 5d f4	 mov	 DWORD PTR _resulti$[ebp], ebx

; 131  : 
; 132  : 
; 133  : 			/*// simple example that xors 2nd byte of data with 14th byte in the key file
; 134  : 			lea esi,gkey				// put the ADDRESS of gkey into esi
; 135  : 			mov esi,gptrKey;			// put the ADDRESS of gkey into esi (since *gptrKey = gkey)
; 136  : 
; 137  : 			lea	esi,gPasswordHash		// put ADDRESS of gPasswordHash into esi
; 138  : 			mov esi,gptrPasswordHash	// put ADDRESS of gPasswordHash into esi (since unsigned char *gptrPasswordHash = gPasswordHash)
; 139  : 
; 140  : 			mov al,byte ptr [esi]				// get first byte of password hash
; 141  : 			mov al,byte ptr [esi+4]				// get 5th byte of password hash
; 142  : 			mov ebx,2
; 143  : 			mov al,byte ptr [esi+ebx]			// get 3rd byte of password hash
; 144  : 			mov al,byte ptr [esi+ebx*2]			// get 5th byte of password hash
; 145  : 
; 146  : 			mov ax,word ptr [esi+ebx*2]			// gets 5th and 6th bytes of password hash ( gPasswordHash[4] and gPasswordHash[5] ) into ax
; 147  : 			mov eax,dword ptr [esi+ebx*2]		// gets 4 bytes, as in:  unsigned int X = *( (unsigned int*) &gPasswordHash[4] );
; 148  : 
; 149  : 			mov al,byte ptr [gkey+ebx]			// get's 3rd byte of gkey[] data
; 150  : 
; 151  : 			mov al,byte ptr [gptrKey+ebx]		// THIS IS INCORRECT - will add the address of the gptrKey global variable (NOT the value that gptrKey holds)
; 152  : 
; 153  : 			mov al,byte ptr [esi+0xd];			// access 14th byte in gkey[]: 0, 1, 2 ... d is the 14th byte
; 154  : 			mov edi,data				// Put ADDRESS of first data element into edi
; 155  : 			xor byte ptr [edi+1],al		// Exclusive-or the 2nd byte of data with the 14th element of the keyfile
; 156  : 			// NOTE: Keyfile[14] = 0x21, that value changes the case of a letter and flips the LSB
; 157  : 			// Capital "B" = 0x42 becomes lowercase "c" since 0x42 xor 0x21 = 0x63	*/
; 158  : 	}
; 159  : 
; 160  : 	return resulti;

  000dc	8b 45 f4	 mov	 eax, DWORD PTR _resulti$[ebp]

; 161  : } // encryptData

  000df	5f		 pop	 edi
  000e0	5e		 pop	 esi
  000e1	5b		 pop	 ebx
  000e2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e5	33 cd		 xor	 ecx, ebp
  000e7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ec	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000f2	3b ec		 cmp	 ebp, esp
  000f4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
?encryptData@@YAHPADH@Z ENDP				; encryptData
_TEXT	ENDS
END
